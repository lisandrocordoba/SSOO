## Ej 20

```c
int main (void) {
    cambiarPassword();
    return 0;
}
void cambiarPassword() {
    int numeroDeUsuario = obtenerUsuarioActual();
    
    char password[250];
    char passwordConfirmacion[250];
    printf("Ingrese su password actual");
    fgets(password, 250, stdin);
    
    if (hash(password) == hashDePasswordActual(numeroDeUsuario)) {
        printf("Ingrese su nuevo password");
        fgets(password,250, stdin);
        printf("Confirme su nuevo password");
        gets(passwordConfirmacion);

        if (sonIguales(password, passwordConfirmacion)) {
            actualizarPassword(numeroDeUsuario, password);
        }
    }
}
```
### 1)
La funcion ``gets`` no restringe la cantidad de caracteres que se pueden leer, por lo que si el usuario ingresa mas de 250 caracteres, se produciria un ``buffer overflow``.  
Veamos como está el stack:

```
DIRECCIONES BAJAS

    passwordConfirmacion[0-3]       <-- puntero a passwordConfirmacion
    ...
    passwordConfirmacion[246-249]
    password[0-3]
    ...
    password[246-249]
    numeroDeUsuario_cP
    rbp_viejo_cP
    ret_address_main
    rbp_viejo_main

DIRECCIONES ALTAS
```
Al no tener limite de escritura, el ``gets`` permite sobreescribir todas las variables y los datos del stack, incluyendo la retAddress.  
Notar que para llegar al ``gets`` el usuario deberia haber ingresado su contraseña correctamente. Una vez que se loguea, el atacante puede pisar el retAddress ejecutando codigo arbitrario.

### 2)
El atacante podria en vez de ejecutar codigo arbitrario pisando el retAddress, pisar las variables ``passwordConfirmacion``, ``password`` y ``numeroDeUsuario`` para modificar la contraseña de otro usuario.  
Por ejemplo:  
El atacante ingresa en ``gets`` una cadena de $250+250+1 = 501$ caracteres, donde los primeros 250 caracteres son ``stringDe250``, los siguientes 250 son ``stringDe250`` y el ultimo caracter es ``03``. 
El programa continuara su ejecucion
```c
if (sonIguales(password, passwordConfirmacion)) {
    actualizarPassword(numeroDeUsuario, password);
}
```
pero le estará modificando la contraseña al usuario 3, con la contraseña ``stringDe250``.


### 3)
El programa deberia modificar el uid efectivo del proceso con `setuid(0)` en el momento de acceder a `etc/shadow`, otorgandole permisos de root y luego volver a cambiar el uid efectivo al uid real del usuario. 

### 4)
Si las contraseñas se almacenan en texto plano, un atacante que logre acceso de lectura a `etc/shadow` podria ver todas las contraseñas de los usuarios.  
Si se almacenan como hashes, no sabria la contraseña original, pero mediante fuerza bruta podria intentar encontrar una cadena que genere el mismo hash.  
Si se usan hashes con salt, contraseñas iguales tendras hashes distintos. Por lo que por mas que el atacante logre una preimagen para el mismo hash mediante fuerza bruta, no podria saber la contraseña pues hash = hash(contraseña + saltAleatorio).