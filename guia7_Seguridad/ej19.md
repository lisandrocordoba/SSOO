## EJ 19
```c
void seleccionar_funcion(unsigned int opcion) {
    func (*funciones)[1000] = [ &f1, &f2, ..., &f1000 ];
    int costos[1000] = [10, 100, 10000, 100000, ..., 10000000];
    if (opcion>=1000) { return; }; // error ;

    usuario *usuario_actual = get_user();
    creditos = usuario_actual->creditos;
    return ejecutar_si_quedan_creditos(&creditos, costos[opcion-1], funciones[opcion-1]);
}

void ejecutar_si_quedan_creditos(int *creditos, int costo, func *f) {
    unsigned int saldo = (*creditos) - costo;
    if (saldo == 0) {
        return; // No tiene crédito.
    }

    // Sí tiene.
    (*f)(); // Se ejecuta f().
    *creditos = saldo; // Se actualiza el saldo.
}
```
### Vulnerabilidad por integer underflow
Supongamos que el usuario tiene ``credito = 1`` y quiere ejecutar la función con `costo = 10`, hay una clara vulnerabilidad en la linea
```c
unsigned int saldo = (*creditos) - costo;
```
ya que al ser `saldo` un `unsigned int`, si `*creditos < costo` tendremos un `integer underflow` y `saldo` tomara un valor muy grande. y podrá ejecutar la funcion por mas que no tenga creditos suficientes. 
De esta forma, un usuario podria llamar muchas veces a `seleccionar_funcion` con la `opcion` cuya funcion tenga el `costo` mas alto, para asi lograr que sus `creditos` tenga el mayor valor posible y ejecutar todas las funciones que quiera.

Esto afecta la integridad del sistema, ya que un usuario podria ejecutar funciones que no deberia poder ejecutar por falta de creditos.

### Vulnerabilidad por falta de validacion de parametros
La funcion `seleccionar_funcion` recibe un `unsigned int opcion` como parametro y valida que sea menor a 1000, pero no valida que sea distinto de 0.  
Luego le envia ``funcion[opcion-1]`` a `ejecutar_si_quedan_creditos` y en el caso de que `opcion = 0`, se estaria enviando `funcion[-1]`, lo cual tendria comportamiento indefinido pues probablemente se le esté enviando el ebp de la funcion llamadora.