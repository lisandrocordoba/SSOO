## Ej 18
```c
void registrar_ganador(char *nombre_ganador, char *frase) {
    char directorio_ganadores[] = "/tmp";
    char archivo_ganador[256];

    snprintf(archivo_ganador, sizeof(archivo_ganador), "%s/%s", directorio_ganadores, nombre_ganador);
    if(!existe_archivo(archivo_ganador)) {
        char command[512];
        snprintf(command, sizeof(command), "echo ’%s’ > %s",
        frase, archivo_ganador);
        system(command);
    }
}
```

### Vulnerabilidades

#### Environment Variable Attack
Al no usar rutas absolutas, un atacante podria modificar la variable de entorno ``PATH`` para ejecutar un binario malicioso en lugar del comando `echo` con permisos de root, pues el juego corre con maximo privilegio.  
Esto permitira por ejemplo al atacante correr un shell con permisos de root, logrando el escalamiento de privilegios.

#### Command Injection
Suponiendo que la funcion llamadora de `registrar_ganador` no sanitiza el contenido de `frase`, un atacante podria inyectar codigo en esta variable.  
Por ejemplo si `frase = "'hola' ; rm -rf / ; echo 'chau'`, el comando ejecutado seria ``echo 'hola' ; rm -rf / ; echo 'chau' > /tmp/nombre_ganador``, lo que resultaria en la eliminacion de todos los archivos del sistema.  
Aca tambien el atacante podria correr un shell con permisos de root, logrando el escalamiento de privilegios.

#### Race condition con uso de links simbolicos
Un atacante podria hacer lo siguiente:

1. registrar_ganador es llamado con un ganador que no tiene archivo, por ejemplo `nombre_ganador = "ganador1"`.
2. El programa entrará al if, pues el archivo `/tmp/ganador1` no existe.
3. Antes de que se ejecute el comando `system`, el atacante gana la race condition y ejecuta `ln -s /etc/shadow /tmp/ganador1`, creando un link simbolico al archivo `/etc/shadow` en `/tmp/ganador1`.
4. El comando `system` se ejecuta, escribiendo ``frase`` en `/etc/shadow`. Si ``frase`` tiene el formato adecuado, el atacante podria agregar un usuario al sistema pues el codigo está corriendo con permisos de root.

