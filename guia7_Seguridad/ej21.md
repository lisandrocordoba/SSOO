## Ej 21

```c
void f(char *input) {
    int a;
    char buffer[16];
    int b;
    // Sintaxis: memcpy(destino, origen, tamano en bytes)
    (void) memcpy(buffer, input, 20);
}
```

### 1)
Sin optimizaciones del compilador, el stack se veria asi:

```
DIRECCIONES BAJAS

    b
    buffer[0-3]     <--- puntero a buffer
    ...
    buffer[12-15]
    a
    ret_address
    rbp_viejo
    input[0-3]
    ...
    input[N-M]

DIRECCIONES ALTAS
```
``memcpy`` copiará los primeros 20 bytes de ``input`` en ``buffer``, pero ``buffer`` solo tiene 16 bytes, por lo que los 4 bytes restantes pisarán la variable ``a``.  
Si bien no es algo deseado, no habria un problema de seguridad pues `a` ni siquiera se utiliza.

### 2)
Si se activa la optimizacin de eliminacion de codigo muerto del compilador, las variables ``a`` y ``b`` seran eliminadas ya que no se utilizan en ningun lado.  
El stack se veria asi:  
```
DIRECCIONES BAJAS

    buffer[0-3]     <--- puntero a buffer
    ...
    buffer[12-15]
    ret_address
    rbp_viejo
    input[0-3]
    ...
    input[N-M]

DIRECCIONES ALTAS
```
En este caso, la variable pisada por el ``memcpy`` sera la ``ret_address``, lo cual si es una vulnerabilidad de seguridad pues un atacante podria ejecutar codigo arbitrario.

### 3)
Como está arriba...