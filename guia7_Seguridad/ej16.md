## EJ 16

```c
/**
* Dado un usuario y una clave, indica si la misma es válida
*/
extern bool clave_es_valida(char* usuario, char* clave);

bool validar_clave_para_usuario(char *usuario){
    // fmt = "%......."
    char fmt[8];
    fmt[0] = ’%’;

    printf("Ingrese un largo para la clave: ");

    // fmt = "%NNNN\0"
    scanf("%4s", fmt+1);
    int l = strlen(fmt+1);

    // max_size <- atoi(NNNN)
    unsigned char max_size = atoi(fmt+1);
    char clave[max_size+1];

    // fmt = "%NNNNs\0"
    fmt[l+1] = ’s’;
    fmt[l+2] = ’\0’;

    scanf(fmt, clave);

    return clave_es_valida(usuario, clave);
}
int main(int argc, char **argv){
    setuid(0);
    bool es_valida = validar_clave_para_usuario(argv[1]);
    if(es_valida) {
        system("/bin/bash");
    } else {
        exit(EXIT_FAILURE);
    }
}
```
### Explicación del codigo
El codigo recibe un usuario como parametro en `argv[1]` y le solicita autenticarse con la contraseña, teniendo setuid(0) activado, es decir ejecutando con privilegios de root. En caso de exito le otorga una consola bash con permisos de root, en otro caso devuelve error.
Para la autenticacion, primero le hace ingresar el largo de la contraseña, con el fin de manejar el formato de la contraseña.
El largo debe ser de 4 digitos, pues se le permiten ingresar 4 chars, por lo que el rango del largo de la contraseña es [-9999, 9999].
En el array `fmt` va armando el formato de la contraseña: primero `fmt = [%, ...]`, luego `fmt = [%, N1, N2, N2, N4, ...]` siento N1N2N3N4 los 4 bytes (1 int) pertenecientes al largo de la contraseña informado por el usuario.  
Finalmente, se termina el formato y queda `fmt = [%, N1, N2, N2, N4, s, \0, ...]`, es decir `fmt = "%Ns\0"` siendo N el largo ingresado por el usuario.  
Luego de tener `fmt` definido, se le pide al usuario la contraseña con ese formato mediante `scanf`. Si es correcta se le otorga la consola bash, sino falla.

### Vulnerabilidad de seguridad
El problema de seguridad está en la linea 
```c
unsigned char max_size = atoi(fmt+1);
```
ya que por el tipo de max_size, se truncara el valor ingresado por el usuario a 1 byte (0 a 255).  
De esta forma, si el usuario ingresa por ejemplo `1000`, el valor de max_size sera `232` (1000 mod 256), pero el formato seguirá siendo ``fmt = "%1000s\0"``.  
Luego, al pedir la contraseña con `scanf(fmt, clave);`, se le permite al usuario ingresar hasta 1000 caracteres, pero el buffer `clave` solo tiene espacio para 233 caracteres (232 + '\0').  
Esto genera un buffer overflow de `clave`, permitiendo sobreescribir variables de la pila y en particular el returnAddress.

### Impacto del ataque
De esta forma, mediante un bufferOverflow se provoca un escalamiento de privilegios, pues un atacante podrá ejecutar código arbitrario con permisos de root.  
Los 2 requisitos fudamentales de la seguridad de la informacion se ven afectados:
- Confidencialidad: Un atacante podrá ejecutar código arbitrario con permisos de root y acceder a información sensible del sistema. Por ejemplo ejecutando ``cat /etc/shadow``.
- Integridad: Un atacante podrá modificar archivos del sistema, por ejemplo ejecutando `echo "usuario:clave" >> /etc/passwd`.
- Disponibilidad: Un atacante podrá deshabilitar servicios del sistema o dejarlo inutilizable, por ejemplo ejecutando `rm -rf /`.

### Mitigación
#### A nivel codigo
Para evitar la vulnerabilidad, se deberia reemplazar ``unsigned char max_size = atoi(fmt+1);`` por `int max_size = atoi(fmt+1);`, de esta forma se evitaria el truncamiento del valor ingresado por el usuario y no se podria provocar un buffer overflow.  
Tambien podriamos chequear que el valor ingresado por el usuario no sea negativo. De esta forma el rango de largo de la contraseña seria [0, 9999].

#### A nivel sistema operativo
- Habilitando los ``Stack Canaries``, el SO se dara cuenta si un buffer overflow sobreescribió el returnAddress y abortará la ejecución del programa.
- Habilitando `Stack randomization`, el SO ubicará la pila en una dirección de memoria aleatoria. Si bien el atacante puede romper el programa, dificultará que se logre un ``escalamiento de privilegios`` mediante la ejecucion de código arbitrario.
- Habilitando `Data Execution Prevention (DEP)`, el SO no permitirá que se ejecute codigo ni del stack ni del heap. De esta forma se evita que un atacante inyecte codigo al stack y luego sobreescriba la direccion de retorno para que apunte a su codigo inyectado.