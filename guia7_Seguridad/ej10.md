## EJ 10: Integer Overflow

Supongamos que el usuario controla stdin

```c
#define BUF_SIZE 1024
int suma_indirecta(void) {
    int buf[BUF_SIZE];
    int i, v;
    memset(buf, 0, sizeof(buf));
    while (cin >> i >> v) { // Leo el índice y el valor
        if (i ==-1) break; // Un índice-1 significa que tengo que terminar.
        if (i < BUF_SIZE) buf[i] = v; // Guardo el valor en el buffer
    }

    // Calculo la suma de los valores
    v = 0;
    for (i=0; i < BUF_SIZE; i++)
    v += buf[i];
    return v;
}
```

### a)
Si bien se chequea que $i$ no sea mayor a BUF_SIZE, si se ingresa un negativo (distinto de -1) se escribira fuera de los límites del buffer.  
Tambien ocurre si $i >= 2^31$ pues el rango de int es $[-2^{31}, 2^{31}-1]$. i desborda y se convierte en un valor negativo, lo que permite escribir fuera de los límites del buffer.

### b)
Asumo arquitectura de 32 bits (4 bytes).
```
DIRECCIONES BAJAS

    buf[0-3]     <-- puntero a buf |
    buf[4-7]                       V
    ...
    buf[1000-1023]
    rbpLlamadora
    retAdress

DIRECCIONES ALTAS
```
A primera vista parece que no se puede sobreescribir el return address, ya que el buffer es de 1024 bytes y el retAdress se encuentra más arriba en la pila, por lo que el chequeo de i < BUF_SIZE impediría escribir en esa dirección.

Sabemos que con un i negativo != -1 este chequeo pasa de largo.
Recordemos como funciona la indexación de arrays:
buf[i] = *(buf + i * sizeof(int)).  
Con un i suficientemente negativo, i * sizeof(int) puede desbordar y convertirse en un valor positivo grande, permitiendo así escribir en direcciones más altas de la pila, incluyendo el return address.



### c)
Podriamos modificar unicamente el return address dejando el canario intacto. De esta forma, al retornar de la función no se detectaria la corrupción del canario y se podria redirigir la ejecución a una dirección arbitraria.

