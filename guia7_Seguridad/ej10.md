## EJ 10: Integer Overflow

Supongamos que el usuario controla stdin

```c
#define BUF_SIZE 1024
int suma_indirecta(void) {
    int buf[BUF_SIZE];
    int i, v;
    memset(buf, 0, sizeof(buf));
    while (cin >> i >> v) { // Leo el índice y el valor
        if (i ==-1) break; // Un índice-1 significa que tengo que terminar.
        if (i < BUF_SIZE) buf[i] = v; // Guardo el valor en el buffer
    }

    // Calculo la suma de los valores
    v = 0;
    for (i=0; i < BUF_SIZE; i++)
    v += buf[i];
    return v;
}
```

### a)
Si bien se chequea que $i$ esté en rango, si se ingresa un negativo (distinto de -1) se escribira fuera de los límites del buffer.  
Tambien ocurre si $i >= 2^31$ pues el rango de int es $[-2^{31}, 2^{31}-1]$. i desborda y se convierte en un valor negativo, lo que permite escribir fuera de los límites del buffer.

### b)
Acediendo a indices negativos del buffer podriamos sobreescribir el return address. 

### c)
Podriamos modificar unicamente el return address dejando el canario intacto. De esta forma, al retornar de la función no se detectaria la corrupción del canario y se podria redirigir la ejecución a una dirección arbitraria.