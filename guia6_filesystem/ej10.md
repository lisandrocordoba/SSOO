# Ej 10
Tenemos un disco formateado con FAT.

Queremos implementar la funcion `datos = cargar_archivo(directorios[])`, que recibe un path representado como un arreglo de strings (por ejemplo, para `/home/pepe/aprobar.txt`, el arreglo seria `["home", "pepe", "aprobar.txt"]`), y devuelve los datos del archivo correspondiente.

Tenemos las funciones auxiliares:
- ``FAT_entry(block_address)``: devuelve la entrada de la tabla FAT de la posicion `block_address`.
- ``raw_data = read_blocks(block_address1, block_address2, ...)``: lee del disco los bloques indicados por parametro en orden.
- ``parse_directory_entries(raw_data)``: devuelve una lista de ``struct_dir_entry``, donde cada elemento representa los subdirectorios del directorio pasado en ``raw_data.``
- ``raw_data = root_table()``: devuelve los datos de la tabla de directorios de root.

## a)
``struct_dir_entry`` debe tener los siguientes campos:
- `name`: string con el nombre del archivo o directorio.
- `start_block`: LBA del bloque inicial del archivo o directorio.
- `size`: tama√±o en bytes del archivo o directorio.
- `attributes`: booleano que indica si es un directorio o un archivo.

## b)

```c
char* cargar_archivo(directorios[]){
    // Primero traemos las dirEntrys de root
    char* raw_data = root_table()
    struct_dir_entry dir_entrys[] = parse_directory_entries(raw_data)
    for archivo_actual in directorios:
        for dirEntry in dir_entrys:

            // Encontramos el archivo_actual
            if (dir_entry.name == archarchivo_actualivo):

                // Guardamos en LBAs_archivo[] todos los LBAs de archivo_actual (ordenados)
                int cantidad_blocks_de_archivo = ceil(dir_entry.size / BLOCK_SIZE)
                int LBAs_archivo[cantidad_blocks_de_archivo.size];
                int block_actual = dir_entry.start_block;
                for i = 0 ... cantidad_blocks_de_archivo-1:
                    LBAs_archivo[i] = block_actual;
                    block_actual = FAT_entry(block_actual)

                // Leemos del disco todos los bloques de archivo_actual
                char* data_archivo_actual[cantidad_blocks_de_archivo * BLOCK_SIZE] = read_block(LBAs_archivo)

                // Si es el ultimo archivo del path, devolvemos los datos
                if(archivo_actual es el ultimo en directorios[]):
                    if(dir_entry.attributes no es archivo):
                        printf("El path es invalido")
                        return error

                    return data_archivo_actual

                // Si no es el ultimo, avanzamos al siguiente directorio del path
                else:
                    if (dir_entry.attributes no es directorio):
                        printf("El path es invalido")
                        return error
                        
                    dir_entrys = parse_directory_entries(data_archivo_actual)
                    break

            // Si recorrimos todas las dirEntrys y no encontramos el siguiente directorio del path, falla
            else if (es la ultima dirEntry):
                printf("No existe el path")
                return error
}  
```