## Hecho en clase
Adaptado: no devolvemos un array, solo printeamos.

#### Idea
inode_for_path(dir). 
recorrer bloques de datos. 
mirar dirEntrys. 
    comparo nombre y tamaño. 
    si cumple -> print. 
    si es dir -> recursion

### Pseudocódigo
```c
void find_file_less_size(char* dir, int min_bytes, char* name){
    Ext2FSInode* inodo = inode_for_path(dir);
    ffls_rec(inodo, min_bytes, name);
}

void ffls_rec(Ext2FSInode* inodo, int min_bytes, char* name){

    // Esta parte es lo que hicimos en el taller
    char* buf = (char*)malloc(2*BLOCK_SIZE);     // Asumimos una dir_entry mide a lo sumo BLOCK_SIZE
    char* buf2 = buf + BLOCK_SIZE;

    int blockNum = 0;
    int LbaBlock1 = get_block_address(blockNum, inodo);
    int LbaBlock2 = get_block_address(blockNum + 1, inodo);

    read_block(LbaBlock1, buf);
    read_block(LbaBlock2, buf2);

    int recorrido = 0;
    int dentryPointer = 0;
    int cantdentrys = 0;
    while(recorrido < inodo->size){
        Ext2FSDirEntry* dentry = (Ext2FSDirEntry*)(buf + dentryPointer);
        cantdentrys++;
        // Si son iguales
        if(!strncmp(dentry->name, name, dentry->sizename)){
            // Ver size en inodo y printear
        }
        // Si es dir y no es '/.' o '..'
        if(dentry->filetype == 'd' && cantdentrys > 2){ 

            Ext2FSInode* inodoD = loadinode(dentry->inode);
            ffls_rec(inodoD, min_bytes, name);
        }

        // Actualizar punteros
        dentryPointer += dentry->rec_len;
        recorrido += dentry->rec_len;
    }
}
```